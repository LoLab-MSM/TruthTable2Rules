
from pysb.core import MonomerPattern, ComplexPattern, RuleExpression, ReactionPattern, ANY, WILD
from pysb.integrate import Solver
from pysb.builder import Builder
from pysb.export.pysb_flat import PysbFlatExporter
import numpy as np
from copy import deepcopy
from itertools import combinations, product
import re
import csv
import random
from math import *
from collections import defaultdict
import datetime
from pysb import ComponentSet


class B_Node:

    def __init__(self):
        self.incidentNodes = []
        self.labels = []
        self.reactions = []
        self.optional_rxns = []
        self.compete = []
        self.sequence = []
        self.exclusive = False
        self.relax = False
        self.depth = 1000
        self.initial = None
        self.motifs = []
        self.self = []
        self.objective = False
        self.boolean = None
        self.boolean_list = None
        self.table = None


def importModel(model_name):

    nodes = {}

    # read in the Boolean model in Booleannet format; this should be separate in the future
    model = open(model_name, 'r')
    bnodes = []
    brules = []
    brules_parced = []
    binputs = []

    within_model = False
    for line in model:

        if '\"\"\"' in line and within_model:
            break

        if within_model:
            # print line
            if '=' in line and '*' not in line:
                s = line.find(' ')
                nodes[line[:s]] = B_Node()
                if line[line.rfind(' ')+1:-1] == 'False':
                    nodes[line[:s]].initial = 0
                if line[line.rfind(' ')+1:-1] == 'True':
                    nodes[line[:s]].initial = 1

            if '*' in line and ':' in line:
                bnodes.append(line[line.index(':')+2:line.index('*')])
                brules.append('('+line[line.index('=') + 2:-1]+')')
                bp = deepcopy(brules[-1])
                bp = bp.replace('(', ' ( ')
                bp = bp.replace(')', ' ) ')
                bp = bp.strip()
                bp = re.split(r'\s*', bp)
                brules_parced.append(bp)
                binputs.append([])

            if '*' in line and ':' not in line:
                bnodes.append(line[:line.index('*')])
                brules.append(line[line.index('=')+2:-1])
                bp = deepcopy(brules[-1])
                bp = bp.replace('(', ' ( ')
                bp = bp.replace(')', ' ) ')
                bp = bp.strip()
                bp = re.split(r'\s*', bp)
                brules_parced.append(bp)
                binputs.append([])

        if '\"\"\"' in line and not within_model:
            within_model = True

    btable = []

    for i, each in enumerate(brules_parced):
        temp = []
        for item in bnodes:
            if item in each:
                temp.append([each.index(item), item])
        temp.sort()
        for item in temp:
            binputs[i].append(item[1])

    for each in binputs:
        btable.append(list(product([True, False], repeat=len(each))))
    for i, each in enumerate(btable):
        for j, item in enumerate(each):
            btable[i][j] = list(btable[i][j])
    for i, each in enumerate(brules_parced):
        for j, item in enumerate(btable[i]):
            rule = deepcopy(each)
            b_list = deepcopy(item)
            inputs = deepcopy(binputs[i])
            for k, every in enumerate(rule):
                for l, thing in enumerate(inputs):
                    if every == thing:
                        rule[k] = str(b_list[l])
            rule = ' '.join(rule)
            # print rule
            btable[i][j].append(eval(rule))

    for i, each in enumerate(bnodes):
        head = deepcopy(binputs[i])
        head.append(each)
        btable[i].insert(0, head)
    for i, each in enumerate(bnodes):
        nodes[each].boolean = brules[i]
        nodes[each].boolean_list = brules_parced[i]
        nodes[each].table = btable[i]
        for item in binputs[i]:
            nodes[each].incidentNodes.append(item)

    # # for model selection only
    # for each in nodes:
    #     opposite = []
    #     for item in nodes[each].table[1:]:
    #         item_copy = deepcopy(item)
    #         item_copy[-1] = False
    #         opposite.append(item_copy)
    #     nodes[each].table.extend(opposite)

    return nodes


class Rxn:

    def __init__(self, mole, base_states, par, react, part, direct, reacts, targs, rxnTemps, instructs, params):
        self.molecule = mole
        self.base_states = base_states
        self.parent = par
        self.reaction = react
        self.partners = part
        self.direction = direct
        self.reactants = reacts
        self.targets = targs
        self.rxnTemplates = rxnTemps
        self.rxnsParsed = []
        self.instructions = instructs
        self.parameters = params


def importLibrary(library_name):

    # read in the library of molecules and their associated reactions
    # todo: add consistency tests
    # todo: make list of reactions a dictionary

    molecule_list = defaultdict(list)

    molecule = None
    base_states = []
    parent = None
    reaction = None
    partners = []
    direction = None
    reactants = []
    targets = []
    rxnTemplate = []
    instructions = []
    parameters = []

    mol_library = open(library_name)
    for line in mol_library:
        if 'molecule:' in line:
            molecule = line.split(':', 1)[1].strip()
        if 'base_state:' in line:
            base_states.append(line.split(':', 1)[1].strip())
        if 'parent:' in line:
            parent = line.split(':', 1)[1].strip()
        if 'reaction:' in line:
            reaction = line.split(':', 1)[1].strip()
        if 'partner:' in line:
            partners.append(line.split(':', 1)[1].strip())
        if 'direction:' in line:
            direction = line.split(':', 1)[1].strip()
        if 'reactant:' in line:
            reactants.append(line.split(':', 1)[1].strip())
        if 'target:' in line:
            targets.append(line.split(':', 1)[1].strip())
        if 'rxnTemplate:' in line:
            rxnTemplate.append(line.split(':', 1)[1].strip())
        if 'instruction:' in line:
            instructions.append(line.split(':', 1)[1].strip())
        if 'parameters:' in line:
            instructions.append(line.split(':', 1)[1].strip())
        if '$$$' in line:
            molecule_list[molecule].append(
                Rxn(molecule, base_states, parent, reaction, partners, direction, reactants, targets, rxnTemplate, instructions, parameters))

            reaction = None
            partners = []
            direction = None
            reactants = []
            targets = []
            rxnTemplate = []
            instructions = []
            parameters = []
        if '+++' in line:
            base_states = []

    return molecule_list


def importLabels(labels, library, nodes):

    label_info = False
    initial = False
    required = False
    optional = False
    exclusive = False
    depth = False
    relax = False
    compete = False
    sequence = False
    objective = False
    self = False
    saturated = False

    with open(labels) as label_file:
        reader = csv.reader(label_file)
        label_list = list(reader)
        for each in label_list:
            if each:
                if each[0].strip() == 'labels':
                    label_info = True
                    initial = False
                    required = False
                    optional = False
                    exclusive = False
                    depth = False
                    relax = False
                    compete = False
                    sequence = False
                    objective = False
                    self = False
                    saturated = False
                    continue
                if each[0].strip() == 'initial values':
                    label_info = False
                    initial = True
                    required = False
                    optional = False
                    exclusive = False
                    depth = False
                    relax = False
                    compete = False
                    sequence = False
                    objective = False
                    self = False
                    saturated = False
                    continue
                if each[0].strip() == 'required reactions':
                    label_info = False
                    initial = False
                    required = True
                    optional = False
                    exclusive = False
                    depth = False
                    relax = False
                    compete = False
                    sequence = False
                    objective = False
                    self = False
                    saturated = False
                    continue
                if each[0].strip() == 'optional reactions':
                    label_info = False
                    initial = False
                    required = False
                    optional = True
                    exclusive = False
                    depth = False
                    relax = False
                    compete = False
                    sequence = False
                    objective = False
                    self = False
                    saturated = False
                    continue
                if each[0].strip() == 'restrict reactions':
                    label_info = False
                    initial = False
                    required = False
                    optional = False
                    exclusive = True
                    depth = False
                    relax = False
                    compete = False
                    sequence = False
                    objective = False
                    self = False
                    saturated = False
                    continue
                if each[0].strip() == 'depth':
                    label_info = False
                    initial = False
                    required = False
                    optional = False
                    exclusive = False
                    depth = True
                    relax = False
                    compete = False
                    sequence = False
                    objective = False
                    self = False
                    saturated = False
                    continue
                if each[0].strip() == 'relax':
                    label_info = False
                    initial = False
                    required = False
                    optional = False
                    exclusive = False
                    depth = False
                    relax = True
                    compete = False
                    sequence = False
                    objective = False
                    self = False
                    saturated = False
                    continue
                if each[0].strip() == 'compete':
                    label_info = False
                    initial = False
                    required = False
                    optional = False
                    exclusive = False
                    depth = False
                    relax = False
                    compete = True
                    sequence = False
                    objective = False
                    self = False
                    saturated = False
                    continue
                if each[0].strip() == 'sequence':
                    label_info = False
                    initial = False
                    required = False
                    optional = False
                    exclusive = False
                    depth = False
                    relax = False
                    compete = False
                    sequence = True
                    objective = False
                    self = False
                    saturated = False
                    continue
                if each[0].strip() == 'objective':
                    label_info = False
                    initial = False
                    required = False
                    optional = False
                    exclusive = False
                    depth = False
                    relax = False
                    compete = False
                    sequence = False
                    objective = True
                    self = False
                    saturated = False
                    continue
                if each[0].strip() == 'self reactions':
                    label_info = False
                    initial = False
                    required = False
                    optional = False
                    exclusive = False
                    depth = False
                    relax = False
                    compete = False
                    sequence = False
                    objective = False
                    self = True
                    saturated = False
                    continue
                if each[0].strip() == 'saturated':
                    label_info = False
                    initial = False
                    required = False
                    optional = False
                    exclusive = False
                    depth = False
                    relax = False
                    compete = False
                    sequence = False
                    objective = False
                    self = False
                    saturated = True
                    continue

                if label_info:
                    for lab in each[1:]:

                        # todo: add exception here
                        if lab.strip() not in library:
                            print lab, 'not in library'

                        nodes[each[0].strip()].labels.append(lab.strip())
                if initial:
                    nodes[each[0].strip()].initial = each[1]

                if required and [each[1].strip(), [x.strip() for x in each[2].split(':')], [x.strip() for x in each[3].split(':')]] not in nodes[each[0].strip()].reactions:
                    nodes[each[0].strip()].reactions.append([each[1].strip(), [x.strip() for x in each[2].split(':')], [x.strip() for x in each[3].split(':')], [x.strip() for x in each[4:]]])
                if optional and [each[1].strip(), [x.strip() for x in each[2].split(':')], [x.strip() for x in each[3].split(':')]] not in nodes[each[0].strip()].optional_rxns:
                    nodes[each[0].strip()].optional_rxns.append([each[1].strip(), [x.strip() for x in each[2].split(':')], [x.strip() for x in each[3].split(':')], [x.strip() for x in each[4:]]])
                    nodes[each[0].strip()].exclusive = True
                if self and [each[1].strip(), [x.strip() for x in each[2].split(':')], [x.strip() for x in each[3].split(':')]] not in nodes[each[0].strip()].self:
                    nodes[each[0].strip()].self.append([each[1].strip(), [x.strip() for x in each[2:]]])
                if exclusive:
                    nodes[each[0].strip()].exclusive = True
                if depth:
                    nodes[each[0].strip()].depth = each[1]
                if relax:
                    nodes[each[0].strip()].relax = True
                if compete:
                    nodes[each[0].strip()].compete.append(each[1].strip())
                if sequence:
                    nodes[each[0].strip()].sequence.append([])
                    for item in each[1:]:
                        nodes[each[0].strip()].sequence[-1].append(item.strip())
                if objective:
                    nodes[each[0].strip()].objective = True
                if saturated:
                    nodes[each[0].strip()].saturated = each[1:]
                    for i, item in enumerate(nodes[each[0].strip()].saturated):
                        nodes[each[0].strip()].saturated[i] = item.strip()


class MotifBuilder:

    def __init__(self, nodes, library, hidden=0, max_depth=100):
        self.nodes = nodes
        self.library = library
        self.hidden = hidden
        self.max_depth = max_depth
        self.master = deepcopy(self.nodes)
        self._build_motifs()

    def _findSelfInteractions(self, n):

        interacts = []
        for this in self.master[n].labels:
            for that in self.library[this]:
                if that.direction == 'self':
                    interacts.append([[None], [n], [None], [that.molecule], 's', that.reaction, that.instructions])

        return interacts

    def _findInteractions(self, root_node, target_node, affecting_nodes):

        targ_list = []
        aff_list = []
        interacts = []

        # build lists of reactions for target 'input', affecting 'output', target 'mutual', and affecting 'mutual' nodes
        for target_label in self.master[target_node].labels:
            for mol in self.library[target_label]:
                if mol.direction == 'input':
                    targ_list.append([target_node, mol.reaction, mol.molecule, mol.reactants, 'input'])

        for aff_node in affecting_nodes:
            for aff_label in self.master[aff_node].labels:
                for mol in self.library[aff_label]:
                    if mol.direction == 'output':
                        aff_list.append([aff_node, mol.reaction, mol.molecule, mol.targets, 'output'])

        # group reactions - target 'input', affecting 'output'
        targ_groups = []
        aff_groups = []

        aff_max = 0
        for rxn in aff_list:
            if len(rxn[3]) > aff_max:
                aff_max = len(rxn[3])
        for r in range(aff_max):
            for combos in combinations(targ_list, r+1):
                targ_groups.append(list(combos))

        targ_max = 0
        for rxn in targ_list:
            if len(rxn[3]) > targ_max:
                targ_max = len(rxn[3])
        for r in range(targ_max):
            for combos in combinations(aff_list, r+1):
                aff_groups.append(list(combos))

        # match input and output reactions
        for t_group in targ_groups:
            for a_group in aff_groups:
                match = True

                # match reaction names
                reaction_name = t_group[0][1]
                for t in t_group:
                    if t[1] != reaction_name:
                        match = False
                for a in a_group:
                    if a[1] != reaction_name:
                        match = False

                # match reactants and targets
                if match:
                    for t in t_group:
                        t3 = deepcopy(t[3])
                        if len(t3) != len(a_group):
                            match = False
                        a2 = []
                        for a in a_group:
                            a2.append(a[2])
                        if set(t3) != set(a2):
                            match = False
                    for a in a_group:
                        a3 = deepcopy(a[3])
                        if len(a3) != len(t_group):
                            match = False
                        t2 = []
                        for t in t_group:
                            t2.append(t[2])
                        if set(a3) != set(t2):
                            match = False

                if match:
                    interact = [[], [], [], [], 'd', reaction_name]
                    for t in t_group:
                        interact[1].append(t[0])
                        interact[3].append(t[2])
                    for a in a_group:
                        interact[0].append(a[0])
                        interact[2].append(a[2])
                    interacts.append(interact)

        # add instructions and partners
        for i, each in enumerate(interacts):
            interacts[i].extend([[], []])
            for item in self.library[each[3][0]]:
                if item.reaction == each[5]:
                    for j, every in enumerate(item.instructions):
                        if every not in interacts[i][6]:
                            interacts[i][6].append(every)
                    for j, every in enumerate(item.partners):
                        if every not in interacts[i][7]:
                            interacts[i][7].append(every)

                            # add parameters
        for i, each in enumerate(interacts):
            interacts[i].append([None])
            for item in self.nodes[root_node].reactions:
                if item[3] and each[5] == item[0] and set(each[0]) == set(item[1]) and set(each[1]) == set(item[2]):
                    interacts[i][-1] = item[3]
                    interacts[i][-1].append('r')
            for item in self.nodes[root_node].optional_rxns:
                if item[3] and each[5] == item[0] and set(each[0]) == set(item[1]) and set(each[1]) == set(item[2]):
                    interacts[i][-1] = item[3]
                    interacts[i][-1].append('o')

        return interacts

    def _findMotifs(self, targs, motif_build, interacts, in_nodes, mots):

        # todo: apply filters to partial motifs

        # for each in motif_build:
        #     print each
        # print

        # depth = self.nodes[motif_build[0][0][0]].depth
        relax = self.nodes[motif_build[0][0][0]].relax

        working_motif = deepcopy(motif_build)

        def max_path_finder(node_i, node_paths, m2, connects):

            for j in connects[node_i]:
                if j != 0:
                    if j not in node_paths:
                        npa = deepcopy(node_paths)
                        npa.append(j)
                        max_path_finder(j, npa, m2, connects)
                else:
                    if len(node_paths) > m2[0]:
                        m2[0] = len(node_paths)

        # motif filters

        # =======================================================================

        # depth check

        depth_g = True

        new_working_motif = []
        for each in working_motif:
            new_working_motif.append(each[:2])

        # simplify the paths for scoring
        simple_motif = deepcopy(new_working_motif)
        still_simplifying = True
        while still_simplifying:
            still_simplifying = False
            for i,item in enumerate(simple_motif):
                if item[1] and len(item[0]) > 1:
                    for every in simple_motif:
                        if every[1] and set(every[0] + every[1]) == set(item[0]):
                            simple_motif[i][0] = every[1]
                            still_simplifying = True
                if item[1] and len(item[1]) > 1:
                    for every in simple_motif:
                        if every[1] and set(every[0] + every[1]) == set(item[1]):
                            simple_motif[i][1] = every[0]
                            still_simplifying = True

        # list all species
        seed = None
        for each in simple_motif:
            if not each[1]:
                seed = each[0]
        incidents = [seed]
        for each in simple_motif:
            if each[0] not in incidents:
                incidents.append(each[0])
            if each[1] and each[1] not in incidents:
                incidents.append(each[1])

        # find all connections
        connections = [[] for _ in incidents]
        for i, each in enumerate(incidents):
            for item in simple_motif:
                if each == item[0]:
                    for j, every in enumerate(incidents):
                        if every == item[1]:
                            connections[i].append(j)

        # find max path
        max_path = [0]
        for i, each in enumerate(incidents):
            max_path_finder(i, [i], max_path, connections)

        # test depth
        target = None
        for each in working_motif:
            if not each[1]:
                target = each[0][0]
        if max_path[0] > min(self.nodes[target].depth, self.max_depth):
            depth_g = False
            # return

        # =======================================================================

        # # cycle_check; eliminates motifs with cycles
        #
        # still_adding = True
        # paths = [working_motif[0][0]]
        # while still_adding:
        #     still_adding = False
        #     new_paths = []
        #     for p in paths:
        #         for inter in working_motif[1:]:
        #             if p[-1] in inter[1]:
        #                 for each in inter[0]:
        #                     q = deepcopy(p)
        #                     q.append(each)
        #                     new_paths.append(q)
        #     for p in new_paths:
        #         if p not in paths:
        #             paths.append(p)
        #             still_adding = True
        #     for each in paths:
        #         if each[-1] in each[:-1]:
        #             return

        # =======================================================================

        # target path check

        path = True
        new_working_motif = []
        for inter in working_motif:
            if not inter[1]:
                new_working_motif.append(inter)
        still_searching = True
        while still_searching:
            still_searching = False
            working_temp = []
            for inter1 in working_motif:
                for inter2 in new_working_motif:
                    if inter1[1] and set(inter1[1]).issubset(set(inter2[0])) and inter1 not in new_working_motif \
                            and inter1 not in working_temp:
                        working_temp.append(inter1)
                        still_searching = True
            new_working_motif.extend(working_temp)
        if len(new_working_motif) != len(working_motif):
            path = False

        # =======================================================================

        # reaction check; guarantees the specified reactions are in the motif

        # reaction = False
        # if path:
        reaction = True
        target = working_motif[0][0][0]
        for each in self.nodes[target].reactions:
            rc = False
            for item in working_motif:
                if each[0] == item[5] and set(each[1]) == set(item[0]) and set(each[2]) == set(item[1]):
                    rc = True
            if not rc:
                reaction = False

        # if relax:
        #     reaction = True

        # =======================================================================

        # exclusivity check; guarantees other reactions will not be in the motif

        # exclusive = True
        # target = working_motif[0][0][0]
        # print target
        # for item in working_motif[1:]:
        #     ec = False
        #     for each in self.nodes[target].reactions:
        #         if each[0] == item[5] and set(each[1]) == set(item[0]) and set(each[2]) == set(item[1]):
        #             ec = True
        #     # print ec
        #     if not ec:
        #         exclusive = False
        #         # return
        # print exclusive
        # if relax:
        #     exclusive = True
        # print exclusive
        # print

        # =======================================================================

        # exclusivity check; guarantees other reactions will not be in the motif

        # exclusive = True
        # target = working_motif[0][0][0]
        # for item in working_motif[1:]:
        #     ec = False
        #     for each in self.nodes[target].reactions:
        #         if each[0] == item[5] and set(each[1]) == set(item[0]) and set(each[2]) == set(item[1]):
        #             ec = True
        #     # print ec
        #     if not ec:
        #         exclusive = False
        #         return

        # print
        # exclusive = False
        # if reaction:
        #     target = working_motif[0][0][0]
        #     if not self.nodes[target].exclusive:
        #         exclusive = True
        #     if self.nodes[target].exclusive and len(working_motif) == len(self.nodes[target].reactions) + 1:
        #         exclusive = True
        #     if not exclusive:
        #         return

        # =======================================================================

        # motif coverage check

        coverage = False
        node_coverage = set()
        for inter in working_motif[1:]:
            if inter[4] == 'd':
                for species in inter[0]:
                    node_coverage.add(species)
        if set.intersection(node_coverage, set(deepcopy(in_nodes))) == set(deepcopy(in_nodes)):
            coverage = True

        if relax:
            coverage = True

        # =======================================================================

        # complex coverage check; checks if complexes are complete motifs

        complex_coverage = True
        for inter1 in working_motif[1:]:
            if len(inter1[0]) > 1:
                current_inter = False
                for inter2 in working_motif[1:]:
                    if set(inter2[0] + inter2[1]) == set(inter1[0]):
                        current_inter = True
                if not current_inter:
                    complex_coverage = False

        if relax:
            complex_coverage = True

        # =======================================================================

        # if working_motif[0][0][0] == 'plcga':
        #     print
        #     for each in working_motif:
        #         print each
        #
        #     print 'depth_g', depth_g
        #     print 'path', path
        #     print 'reaction', reaction
        #     print 'coverage', coverage
        #     print 'complex_coverage', complex_coverage
        #     print
        #     print '------------------------------'
        #     print

        # add motif to motifs or partials
        if depth_g and path and reaction and coverage and complex_coverage:
            if working_motif not in mots:
                mots.append(working_motif)

        # find interactions for the current targs
        current_interactions = []
        new_interacts = deepcopy(interacts)
        for targ in targs:
            for n, inter in reversed(list(enumerate(new_interacts))):
                inter_set = set(deepcopy(inter[1]))
                targ_set = set(deepcopy(targ[0]))
                if inter_set.issubset(targ_set):
                    current_interactions.append(new_interacts.pop(n))

        # add the new interactions to create new motifs
        for m in range(len(current_interactions)):
            for combin in combinations(current_interactions, m+1):
                new_targs = deepcopy(list(combin))
                new_motif_build = deepcopy(motif_build) + deepcopy(list(combin))

                self._findMotifs(new_targs, new_motif_build, new_interacts, in_nodes, mots)

    @staticmethod
    def _motif_size(motif):

        def path_finder(node_i, node_paths, s, connects):

            for k in connects[node_i]:
                if k != 0:
                    if k not in node_paths:
                        npa = deepcopy(node_paths)
                        npa.append(k)
                        path_finder(k, npa, s, connects)
                else:
                    s[0] += len(node_paths)

        motif2 = []
        for each in motif:
            motif2.append(each[:2])

        # simplify the motif for scoring
        simple_motif = deepcopy(motif2)
        still_simplifying = True
        while still_simplifying:
            still_simplifying = False
            for i, item in enumerate(simple_motif):
                if item[1] and len(item[0]) > 1:
                    for every in simple_motif:
                        if every[1] and set(every[0] + every[1]) == set(item[0]):
                            simple_motif[i][0] = every[1]
                            still_simplifying = True
                if item[1] and len(item[1]) > 1:
                    for every in simple_motif:
                        if every[1] and set(every[0] + every[1]) == set(item[1]):
                            simple_motif[i][1] = every[0]
                            still_simplifying = True

        # duplicate reaction elimination
        simple_temp = []
        for each in simple_motif:
            if each not in simple_temp:
                simple_temp.append(deepcopy(each))

        simple_motif = simple_temp

        # list all species
        seed = None
        for each in simple_motif:
            if not each[1]:
                seed = each[0]
        incidents = [seed]
        for each in simple_motif:
            if each[0] not in incidents:
                incidents.append(each[0])
            if each[1] and each[1] not in incidents:
                incidents.append(each[1])

        # find all connections
        connections = [[] for _ in incidents]
        for i, each in enumerate(incidents):
            for item in simple_motif:
                if each == item[0]:
                    for j, every in enumerate(incidents):
                        if every == item[1]:
                            connections[i].append(j)

        # score motif
        score = [len(motif)-1]
        for i, each in enumerate(incidents):
            path_finder(i, [i], score, connections)

        return score[0]

    def _filter_interactions(self, root, interacts):

        new_interacts = []
        if self.nodes[root].exclusive:
            reactions = deepcopy(self.nodes[root].reactions)
            reactions.extend(deepcopy(self.nodes[root].optional_rxns))
            for each in reactions:
                for item in interacts:
                    if each[0] == item[5] and set(each[1]) == set(item[0]) and set(each[2]) == set(item[1]):
                        new_interacts.append(item)
        else:
            new_interacts = interacts

        return new_interacts

    def _build_motifs(self):

        for node in self.nodes:
            self.nodes[node].self = self._findSelfInteractions(node)
            nodelist = deepcopy(self.nodes[node].incidentNodes)

            if not nodelist:
                self.nodes[node].motifs.extend([[0, [[[node], None, None, None, None, None, None, None]]]])
            else:
                seed = [[[node], None, None, None, None, None, None, None]]
                interactions = []
                interactions += self._findInteractions(node, node, nodelist)

                motifs = []
                interactions = self._filter_interactions(node, interactions)
                self._findMotifs(seed, seed, interactions, self.nodes[node].incidentNodes, motifs)
                if motifs:
                    scored_motifs = []
                    for each in motifs:
                        scored_motifs.append([self._motif_size(each), each])
                    scored_motifs.sort()
                    self.nodes[node].motifs.extend(scored_motifs)


class Combine_and_Build:

    def __init__(self, nodes, library, multi_cell=False, input_type='unsigned', output_type='mechanistic', states='internal', top=1):
        self.nodes = nodes
        self.library = library
        self.multi_cell = multi_cell
        self.states = states
        self.output_type = output_type
        self.input_type = input_type
        self.models = []
        self.reduced_models = []
        self.pysb_models = []
        self._combine(top)

    @staticmethod
    def reachable(node, interactions):

        reached = [node]
        current = [node]
        affected = []
        still_searching = True
        while still_searching:
            still_searching = False
            for interaction in interactions:
                for cur in current:
                    if cur in interaction[0]:
                        affected.extend(interaction[1])

            affected = list(set(affected))
            current = []
            for aff in affected:
                if aff not in reached:
                    reached.append(aff)
                    current.append(aff)
                    still_searching = True
            affected = []

        return reached

    def model_filter(self, targets, optionals, motifs):

        interactions = []
        for motif in motifs:
            for interaction in motif:
                if interaction[1]:
                    interactions.append(interaction)

        active = []
        for opt in optionals:
            for interaction in interactions:
                if opt[0] == interaction[5] and set(opt[1]) == set(interaction[0])\
                        and set(opt[2]) == set(interaction[1]):
                    active.extend(opt[1])
        active = list(set(active))

        reached = []
        for each in self.nodes:
            reached.append(self.reachable(each, interactions))

        connected_components = []
        while reached:
            found = False
            current = reached.pop(0)
            for i, each in enumerate(reached):
                if set(current).intersection(set(each)):
                    reached[i] = list(set(current).union(set(each)))
                    found = True
                    break
            if not found:
                connected_components.append(current)

        isolated = False
        for each in active:
            comp_ind = None
            for i, item in enumerate(connected_components):
                if each in item:
                    comp_ind = i
                    break
            cur_interaction = False
            for item in targets:
                for i, every in enumerate(connected_components):
                    if item in every and i == comp_ind:
                        cur_interaction = True
            if not cur_interaction:
                isolated = True

        return isolated

    def _combine(self, top):

        node_list = []
        motif_list = []
        score = 0
        for node in self.nodes:
            node_list.append(node)
            motif_list.append(self.nodes[node].motifs)
            score += self.nodes[node].motifs[0][0]

        motif_combos = []

        if top == 'all':
            num_motifs = []
            for each in motif_list:
                num_motifs.append(range(len(each)))

            for indices in product(*num_motifs):
                motif = []
                for i, each in enumerate(motif_list):
                    motif.append(each[indices[i]][1])
                motif_combos.append(motif)

        else:
            top_list = [[score, [0 for _ in self.nodes]]]
            for i in range(top-1):
                top_list.append([1000000+i, []])
            current_model_list = [[score, [0 for _ in self.nodes]]]

            # todo: this is inefficient
            # while new potential models are still being generated

            while current_model_list:

                # a round of bfs
                new_model_list = []
                for model in current_model_list:
                    for i, node in enumerate(model[1]):
                        if model[1][i]+1 < len(motif_list[i]):
                            new_model = model[1][:]
                            new_model[i] += 1
                            score = 0
                            for j, each in enumerate(motif_list):
                                score += each[new_model[j]][0]
                            if score <= top_list[-1][0] and [score, new_model] not in new_model_list:
                                new_model_list.append([score, new_model])
                new_model_list.sort()
                current_model_list = []

                # add models to top list, sort and filter
                for each in new_model_list:
                    if each[0] <= top_list[-1]:
                        top_list.append(deepcopy(each))
                        top_list.sort()
                        top_values = []
                        for item in top_list:
                            if item[0] not in top_values:
                                top_values.append(item[0])
                        top_values = top_values[:top]

                        new_top_list = []
                        for i, item in enumerate(top_list):
                            if item[0] in top_values:
                                new_top_list.append(deepcopy(item))
                        top_list = new_top_list
                        current_model_list.append(deepcopy(each))

            tl2 = []
            for each in top_list:
                if each[1]:
                    tl2.append(each)
            top_list = tl2

            # find combinations of motifs
            for each in top_list:
                motifs = []
                for i, node in enumerate(node_list):
                    motifs.append(self.nodes[node].motifs[each[1][i]][1])
                motif_combos.append(motifs)

        # filter out_0 models that are effectively redundant
        targets = []
        for each in self.nodes:
            if self.nodes[each].objective:
                targets.append(each)

        optionals = []
        for each in self.nodes:
            for item in self.nodes[each].optional_rxns:
                optionals.append(item)

        mt = []
        for each in motif_combos:
            isolated = self.model_filter(targets, optionals, each)
            if not isolated:
                mt.append(each)
        motif_combos = mt

        # reorder interactions
        for i, each in enumerate(motif_combos):
            for j, item in enumerate(each):
                if item[0][1]:
                    for k,every in enumerate(item):
                        if not every[1]:
                            motif_combos[i][j].insert(0, motif_combos[i][j].pop(k))

        for i, each in enumerate(motif_combos):

            name = 'model_' + str(i) + '_motifs'
            f = open('/home/mak/models/motifs/'+name, 'w+')

            for item in each:
                for every in item:
                    f.write(str(every) + '\n')
                f.write('\n')
            f.close()

        # generate list of models, expanding for proxy nodes
        for i, each in enumerate(motif_combos):
            copy_nodes = deepcopy(self.nodes)
            for item in each:
                c_node = None
                for em in item:
                    if not em[1]:
                        c_node = em[0][0]
                copy_nodes[c_node].motifs = item
            table_combos = []
            n = 0

            for item in copy_nodes:
                t = copy_nodes[item].table[1:]
                t0 = list(product([True, False], repeat=0))

                tables = []
                for every in t0:
                    t2 = [[]]
                    t2[-1].extend(copy_nodes[item].table[0])
                    for thing in t:
                        t2.append(list(every))
                        t2[-1].extend(thing)
                    tables.append(t2)
                table_combos.append(tables)
                n += 1
            table_list = list(product(*table_combos))

            for item in table_list:
                copy_copy_nodes = deepcopy(copy_nodes)
                for every in item:
                    copy_copy_nodes[every[0][-1]].table = every
                ModelBuilder(i, copy_copy_nodes, self.library, self.pysb_models)


class ModelBuilder(Builder):
    """
    Assemble a PySB model from a Boolean model.
    """
    def __init__(self, num, nodes, library, pysb_models, iv_type='distribute'):

        super(ModelBuilder, self).__init__()
        self.num = num
        self.nodes = nodes
        self.library = library
        self.pysb_models = pysb_models
        self.monomer_info = defaultdict(list)
        self.action_info = defaultdict(list)
        self.base_states = defaultdict(list)
        self.active_states = defaultdict(list)
        self.inactive_states = defaultdict(list)
        self.iv_inactive_states = defaultdict(list)
        self.iv_type = iv_type
        self._build()
        self._export()

    def _build(self):

        self._parse()
        self._get_monomer_info()
        self._add_monomers()
        self._add_rules()
        self._add_initials()
        self._add_observables()

    def _parse(self):

        # parse library reactions
        for every in self.library:
            for thing in self.library[every]:
                for each in thing.rxnTemplates:
                    mols = re.split(r'\s*>>\s*|\s*\+\s*|\s*<>\s*|\s*%\s*', each)
                    ops = re.findall(r'\s*>>\s*|\s*\+\s*|\s*<>\s*|\s*%\s*', each)
                    parced = []
                    for m in mols:
                        parced.append([])
                        sites = []
                        states = []
                        if '(' in m:
                            parced[-1].append(m[:m.index('(')])
                            if '()' not in m:
                                ms = re.split(r'\s*=\s*|\s*,\s*', m[m.index('(') + 1:-1])
                                sites.extend(ms[::2])
                                for s in ms[1::2]:
                                    states.append(s)
                        else:
                            parced[-1].append(m)
                        parced[-1].append(sites)
                        parced[-1].append(states)
                    parced_rxn = [parced.pop(0)]
                    for i, m in enumerate(parced):
                        parced_rxn.append(ops[i])
                        parced_rxn.append(m)
                    thing.rxnsParsed.append(parced_rxn)

        for node in self.nodes:
            for inter in self.nodes[node].motifs:
                if inter[1]:
                    for every in self.library[inter[3][0]]:
                        if every.reaction == inter[5]:
                            pass

    def _export(self):

        # f = open('/home/mak/models/models/model_' + str(self.num) + '.py', 'w+')
        # f.write(PysbFlatExporter(self.model).export())
        # f.close()
        #
        # f = open('/home/mak/models/models/model_' + str(self.num) + '.py', "r")
        # contents = f.readlines()
        # f.close()
        #
        # contents.insert(2, 'import numpy as np\nfrom pysb.integrate import Solver\nimport pylab as pl\nimport matplotlib.pyplot as plt\n')
        #
        # f = open('/home/mak/models/models/model_' + str(self.num) + '.py', "w")
        # contents = "".join(contents)
        # f.write(contents)
        # f.close()

        # ------------------------------

        f = open('model_' + str(self.num) + '.py', 'w+')
        f.write(PysbFlatExporter(self.model).export())
        f.close()

        f = open('model_' + str(self.num) + '.py', "r")
        contents = f.readlines()
        f.close()

        contents.insert(2, 'import numpy as np\nfrom pysb.integrate import Solver\nimport pylab as pl\nimport matplotlib.pyplot as plt\n')

        f = open('model_' + str(self.num) + '.py', "w")
        contents = "".join(contents)
        f.write(contents)
        f.close()

    def _find_sites(self, interaction):

        if interaction[1]:

            monomer_names = []
            monomer_labels = []
            monomer_sites = []

            # get names and labels from interaction and initialize lists
            for i, each in enumerate(interaction[0]):
                monomer_names.append(each)
                monomer_labels.append(interaction[2][i])
                monomer_sites.append({})
            for i, each in enumerate(interaction[1]):
                monomer_names.append(each)
                monomer_labels.append(interaction[3][i])
                monomer_sites.append({})

            # break down reaction template and add sites and states
            for every in self.library[interaction[3][0]]:
                if every.reaction == interaction[5]:
                    for thing in every.rxnTemplates:
                        rxn_template = thing
                        rxnTemp = re.split(r'\s*:', rxn_template)[0]
                        mol_list = re.split(r'\s*>>\s*|\s*\+\s*|\s*<>\s*|\s*%\s*', rxnTemp)
                        for m in mol_list:
                            if '(' in m and '()' not in m:
                                mol = m[:m.index('(')]
                                sites = re.split(r'\s*=\s*|\s*,\s*', m[m.index('(') + 1:-1])[::2]
                                states = re.split(r'\s*=\s*|\s*,\s*', m[m.index('(') + 1:-1])[1::2]
                                for i, each in enumerate(sites):
                                    if each not in monomer_sites[monomer_labels.index(mol)]:
                                        monomer_sites[monomer_labels.index(mol)][each] = []
                                        monomer_sites[monomer_labels.index(mol)][each].append(states[i])
                                    else:
                                        if states[i] not in monomer_sites[monomer_labels.index(mol)][each]:
                                            monomer_sites[monomer_labels.index(mol)][each].append(states[i])

            # rename the sites appropriately
            for i, each in enumerate(monomer_names):
                for item in monomer_sites[i]:
                    if item in monomer_labels:
                        monomer_sites[i][monomer_names[monomer_labels.index(item)]] = monomer_sites[i].pop(item)
                    s1 = item[:item.rfind('_')]
                    s2 = item[item.rfind('_')+1:]
                    if s1 in monomer_labels and s2 == 's':
                        monomer_sites[i][monomer_names[monomer_labels.index(s1)]+'_s'] = monomer_sites[i].pop(item)
                    if s1 in monomer_labels and s2.isdigit():
                        monomer_sites[i][monomer_names[monomer_labels.index(s1)]+'_'+s2] = monomer_sites[i].pop(item)

            # add sites to monomer_info
            for i, each in enumerate(monomer_names):
                for item in monomer_sites[i]:
                    if item not in self.monomer_info[each][0]:
                        self.monomer_info[each][0].append(item)

            # initiate state sites in monomer_info
            for i, each in enumerate(monomer_names):
                for j, item in enumerate(monomer_sites[i]):
                    if item in self.monomer_info or (item[:item.rfind('_')] and item[item.rfind('_')+1:].isdigit()):
                        pass
                    else:
                        if item in self.monomer_info[each][1]:
                            pass
                        else:
                            self.monomer_info[each][1][item] = []

            # add state sites to monomer_info
            for i, each in enumerate(monomer_names):
                for j, item in enumerate(monomer_sites[i]):
                    if item in self.monomer_info or (item[:item.rfind('_')] and item[item.rfind('_')+1:].isdigit()):
                        pass
                    else:
                        for every in monomer_sites[i][item]:
                            if every not in self.monomer_info[each][1][item]:
                                self.monomer_info[each][1][item].append(every)

    def _get_monomer_info(self):

        # initiate monomer information
        for motif in self.nodes:
            for interaction in self.nodes[motif].motifs:
                if interaction[1]:
                    for i, species in enumerate(interaction[0]):
                        if species not in self.monomer_info:
                            self.monomer_info[species] = [[], {}]
                    for i, species in enumerate(interaction[1]):
                        if species not in self.monomer_info:
                            self.monomer_info[species] = [[], {}]
                else:
                    for i, species in enumerate(interaction[0]):
                        if species not in self.monomer_info:
                            self.monomer_info[species] = [[], {}]

        # find binding and state sites; inferred from motifs/self interactions and library
        for node in self.nodes:
            for interaction in self.nodes[node].self:
                self._find_sites(interaction)

        for node in self.nodes:
            for interaction in self.nodes[node].motifs:
                self._find_sites(interaction)

        # print
        # print 'MONOMER INFO'
        # for each in self.monomer_info:
        #     print each, self.monomer_info[each]
        # print

    def _add_monomers(self):

        for each in self.monomer_info:
            if self.nodes[each].compete:
                sites = self.monomer_info[each][0]
                for item in self.nodes[each].compete:
                    comps = item.split(':')
                    comp_site = ''
                    for every in comps:
                        comp_site += every + '_'
                    comp_site = comp_site[:-1]
                    for i, every in reversed(list(enumerate(sites))):
                        if every in comps:
                            sites.pop(i)
                    sites.append(comp_site)
                self.monomer(each, sites, self.monomer_info[each][1])
            else:
                self.monomer(each, self.monomer_info[each][0], self.monomer_info[each][1])

    def _get_action_info(self):

        for motif in self.nodes:
            motif_action = []
            for interaction in self.nodes[motif].motifs:
                if interaction[1]:
                    reactants = interaction[0]
                    targets = interaction[1]
                    target_states = [[[], [], []] for _ in range(len(targets))]
                    for every in self.library[interaction[3][0]]:
                        if every.reaction == interaction[5]:
                            for thing in every.rxnTemplates:
                                mol_list = re.split(r'\s*>>\s*|\s*\+\s*|\s*<>\s*|\s*%\s*', thing)
                                mol_list2 = []
                                for m in mol_list:
                                    mol_list2.append(re.split(r'\s*\(\s*|\s*,\s*|\s*=\s*', m[:-1]))
                                for i, each in enumerate(mol_list2):
                                    for j, item in enumerate(each):
                                        for k, stuff in enumerate(interaction[2]):
                                            if stuff == item:
                                                mol_list2[i][j] = interaction[0][k]
                                            if stuff + '_s' == item:
                                                mol_list2[i][j] = interaction[0][k] + '_s'
                                        for k, stuff in enumerate(interaction[3]):
                                            if stuff == item:
                                                mol_list2[i][j] = interaction[1][k]
                                            if stuff + '_s' == item:
                                                mol_list2[i][j] = interaction[1][k] + '_s'
                                reactant_present = [False for _ in range(len(reactants))]
                                for each in mol_list2:
                                    for i, item in enumerate(reactants):
                                        if each[0] == item:
                                            reactant_present[i] = True
                                if all(reactant_present):
                                    for i, each in enumerate(mol_list2):
                                        if len(each) == 2 and each[1] == '':
                                            mol_list2[i].append('')
                                    for each in mol_list2:
                                        for i, item in enumerate(targets):
                                            if each[0] == item and each[1]:
                                                if not target_states[i][0]:
                                                    target_states[i][0] = each[1::2]
                                                    target_states[i][1] = each[2::2]
                                                else:
                                                    target_states[i][2] = each[2::2]
                                    for i in range(len(target_states)):
                                        if not target_states[i][2]:
                                            target_states[i][2] = target_states[i][1]
                    motif_action.append([interaction[0], interaction[1], target_states])
            self.action_info[motif] = motif_action

        # print
        # print 'ACTION INFO'
        # for each in self.action_info:
        #     for item in self.action_info[each]:
        #         print each, item
        # print

    def _add_rules(self):

        self._get_action_info()

        # print
        # print 'ACTION INFO'
        # for each in self.action_info:
        #     for item in self.action_info[each]:
        #         print each, item
        # print

        # create dictionary of base states
        for each in self.monomer_info:
            mon_obj = self.model.monomers[each]
            states = {}
            for item in mon_obj.sites:
                if item in mon_obj.site_states:
                    states[item] = 'off'
                else:
                    states[item] = 'None'
            state_list1 = []
            state_list2 = []
            for item in states:
                state_list1.append(item)
                state_list2.append(states[item])
            state_list3 = [deepcopy(state_list1), deepcopy(state_list2)]
            self.base_states[each] = state_list3

        # print 'BASE STATES'
        # for each in self.base_states:
        #     print each, self.base_states[each]
        # print

        # create dictionary of active states based on the Boolean equations
        for each in self.monomer_info:
            a_states = []
            i_states = []

            if each in self.nodes:  # if model node; else proxy node
                table = self.nodes[each].table
                for item in table[1:]:  # find all combinations of active incident nodes that activate the target
                    if item[-1]:
                        boole = defaultdict(bool)  # dictionary of incident node Boolean states on a given row
                        for i, every in enumerate(table[0][:-1]):
                            boole[every] = item[i]

                        # run through all actions for a given motif; consider only those acting on the target node
                        # add sites for active incident nodes
                        sites = {}
                        for every in self.action_info[each]:
                            if every[1][0] == each:
                                for thing in every[0]:
                                    if thing in boole and boole[thing]:
                                        for j, lotsa in enumerate(every[2][0][0]):
                                            if lotsa not in sites and every[2][0][1][j] != every[2][0][2][j]:
                                                sites[lotsa] = every[2][0][2][j]

                        # add sites for inactive incident nodes
                        for every in self.action_info[each]:
                            if every[1][0] == each:
                                for thing in every[0]:
                                    if thing in boole and not boole[thing]:
                                        for j, lotsa in enumerate(every[2][0][0]):
                                            if lotsa not in sites and every[2][0][1][j] != every[2][0][2][j]:
                                                sites[lotsa] = every[2][0][1][j]

                        if sites not in a_states:
                            a_states.append(sites)

                    else:
                        boole = defaultdict(bool)  # dictionary of incident node Boolean states on a given row
                        for i, every in enumerate(table[0][:-1]):
                            boole[every] = item[i]

                        # run through all actions for a given motif; consider only those acting on the target node
                        # add sites for active incident nodes
                        sites = {}
                        for every in self.action_info[each]:
                            if every[1][0] == each:
                                for thing in every[0]:
                                    if thing in boole and boole[thing]:
                                        for j, lotsa in enumerate(every[2][0][0]):
                                            if lotsa not in sites and every[2][0][1][j] != every[2][0][2][j]:
                                                sites[lotsa] = every[2][0][2][j]

                        # add sites for inactive incident nodes
                        for every in self.action_info[each]:
                            if every[1][0] == each:
                                for thing in every[0]:
                                    if thing in boole and not boole[thing]:
                                        for j, lotsa in enumerate(every[2][0][0]):
                                            if lotsa not in sites and every[2][0][1][j] != every[2][0][2][j]:
                                                sites[lotsa] = every[2][0][1][j]
                        if sites not in i_states:
                            i_states.append(sites)

                    self.active_states[each] = a_states
                    self.inactive_states[each] = i_states

        # create rules
        used_interactions = []
        for node in self.nodes:
            for interaction in self.nodes[node].motifs:
                if interaction[1] and interaction not in used_interactions:
                    used_interactions.append(interaction)
                    params = deepcopy(interaction[8])

                    # retrieve rxn, reaction template, and instructions
                    current_rxn = None
                    for rxn in self.library[interaction[3][0]]:
                        if rxn.reaction == interaction[5]:
                            current_rxn = rxn

                    n = 0
                    for temp in current_rxn.rxnTemplates:

                        rxnTemp1 = re.split(r'\s*:\s*', temp)
                        rxnTemp = rxnTemp1[0]
                        rxnInstruction = current_rxn.instructions

                        # split template
                        rxn_split = re.split(r'\s*>>\s*|\s*\+\s*|\s*<>\s*|\s*%\s*', rxnTemp)
                        rxn_split_mols = []
                        for each in rxn_split:
                            mol = each.split('(')[0]
                            sites = each.split('(')[1][:-1]
                            site_names = []
                            site_values = []
                            if sites:
                                sites = sites.split(',')
                                for item in sites:
                                    site_names.append(item.split('=')[0].strip())
                                    site_values.append(item.split('=')[1].strip())
                            rxn_split_mols.append([mol, site_names, site_values])
                        ops = re.findall(r'\s*>>\s*|\s*\+\s*|\s*<>\s*|\s*%\s*', rxnTemp)
                        for i, each in enumerate(ops):
                            ops[i] = ops[i].strip()
                        rxn_split_parsed = [rxn_split_mols[0]]
                        for i, each in enumerate(ops):
                            rxn_split_parsed.append(each)
                            rxn_split_parsed.append(rxn_split_mols[i + 1])

                        # Here we make substitutions from the interaction to the template.
                        # Note that the motif generation step does not differentiate between identical
                        # species from different cells. Because the substitutions relies on information
                        # from that step we must account for those identical species here.
                        # !!!!!!!!!!!!!! NEEDS SIMPLIFICATION !!!!!!!!!!!!!!!!!!!

                        for j, each in enumerate(interaction[2]):
                            for i, item in enumerate(rxn_split_parsed):
                                if item != '>>' and item != '<>' and item != '+' and item != '%':
                                    if item[0] == each:
                                        rxn_split_parsed[i][0] = interaction[0][j]
                                    for k, every in enumerate(item[1]):
                                        if every == each:
                                            rxn_split_parsed[i][1][k] = interaction[0][j]
                                        if every[:every.rfind('_')] == each and (every[every.rfind('_')+1:].isdigit() or every[every.rfind('_')+1:] == 's'):
                                            rxn_split_parsed[i][1][k] = interaction[0][j] + every[every.rfind('_'):]

                        for j, each in enumerate(interaction[3]):
                            for i, item in enumerate(rxn_split_parsed):
                                if item != '>>' and item != '<>' and item != '+' and item != '%':
                                    if item[0] == each:
                                        rxn_split_parsed[i][0] = interaction[1][j]
                                    for k, every in enumerate(item[1]):
                                        if every == each:
                                            rxn_split_parsed[i][1][k] = interaction[1][j]
                                        if every[:every.rfind('_')] == each and (every[every.rfind('_')+1:].isdigit() or every[every.rfind('_')+1:] == 's'):
                                            rxn_split_parsed[i][1][k] = interaction[0][j] + every[every.rfind('_'):]

                        rxn_split_parsed_reverse = deepcopy(rxn_split_parsed)
                        rxn_split_parsed_reverse[2][2], rxn_split_parsed_reverse[6][2] = rxn_split_parsed_reverse[6][2], rxn_split_parsed_reverse[2][2]

                        rsp_list = []
                        react = rxn_split_parsed[0][0]
                        for each in self.active_states[react]:
                            rsp = deepcopy(rxn_split_parsed)
                            for item in each:
                                rsp[0][1].append(item)
                                rsp[0][2].append(each[item])
                                rsp[4][1].append(item)
                                rsp[4][2].append(each[item])
                            if rsp not in rsp_list:
                                rsp_list.append(rsp)
                            # print rsp
                        for each in self.inactive_states[react]:
                            rspr = deepcopy(rxn_split_parsed_reverse)
                            for item in each:
                                rspr[0][1].append(item)
                                rspr[0][2].append(each[item])
                                rspr[4][1].append(item)
                                rspr[4][2].append(each[item])
                            if rspr not in rsp_list:
                                rsp_list.append(rspr)
                            # print rspr

                        # for each in rsp_list:
                        #     print each
                        # print

                        for rsp in rsp_list:
                            print rsp
                            # substitute integer for 'integer' and None for 'None'
                            for i, item in enumerate(rsp):
                                if item != '+' and item != '%' and item != '>>' and item != '<>':
                                    for j, every in enumerate(item[2]):
                                        if item[1][j][:item[1][j].rfind('_')] in self.nodes and isinstance(item[1][j][item[1][j].rfind('_') + 1:], int)\
                                                and every != 'None' and every != 'ANY' and every != 'WILD':
                                            rsp[i][2][j] = int(rsp[i][2][j])
                                        if item[1][j] in self.nodes and every != 'None' and every != 'ANY' and every != 'WILD':
                                            rsp[i][2][j] = int(rsp[i][2][j])
                                        if every == 'None':
                                            rsp[i][2][j] = None
                                        if every == 'ANY':
                                            rsp[i][2][j] = ANY
                                        if every == 'WILD':
                                            rsp[i][2][j] = WILD

                            # define the rule rule_name
                            rule_name = ''
                            for item in interaction[0]:
                                if item:
                                    rule_name += item + '_'
                                else:
                                    rule_name = rule_name[:-1]
                            rule_name += interaction[5] + '_'
                            for item in interaction[1]:
                                if item:
                                    rule_name += item + '_'
                            rule_name += str(n)

                            # define monomer patterns
                            mon_pats = []
                            for item in rsp:
                                if item == '+' or item == '%' or item == '>>' or item == '<>':
                                    mon_pats.append(item)
                                else:
                                    if item[0] == 'None':
                                        mon_pats.append('None')
                                    else:
                                        mon_states = {}
                                        for i, every in enumerate(item[1]):
                                            mon_states[every] = item[2][i]
                                        mon_obj = self.model.monomers[item[0]]
                                        mon_pats.append(MonomerPattern(mon_obj, mon_states, None))

                            # define complex patterns
                            com_pats_temp = [[]]
                            for item in mon_pats:
                                if item == '>>' or item == '<>':
                                    com_pats_temp.extend([item, []])
                                elif item == '+':
                                    com_pats_temp.append([])
                                elif item == '%':
                                    pass
                                else:
                                    com_pats_temp[-1].append(item)
                            com_pats = []
                            for item in com_pats_temp:
                                if item == '>>' or item == '<>':
                                    com_pats.append(item)
                                elif item == ['None']:
                                    pass
                                else:
                                    com_pats.append(ComplexPattern(item, None))

                            # define reversibility and split patterns into reactants and products
                            react_com_pats = []
                            prod_com_pats = []
                            carrot = 0
                            reversible = None
                            for item in com_pats:
                                if item == '<>':
                                    carrot = 1
                                    reversible = True
                                elif item == '>>':
                                    carrot = 1
                                    reversible = False
                                else:
                                    if carrot == 0:
                                        react_com_pats.append(item)
                                    if carrot == 1:
                                        prod_com_pats.append(item)
                            order = [len(react_com_pats), len(prod_com_pats)]

                            # define rule expression
                            rule_exp = RuleExpression(ReactionPattern(react_com_pats),
                                                      ReactionPattern(prod_com_pats),
                                                      reversible)

                            set_params = True
                            if params == [None]:
                                set_params = False

                            # create the rate parameters and rule
                            if set_params:
                                if reversible:
                                    forward = rule_name + '_' + str(order[0]) + 'kf'
                                    reverse = rule_name + '_' + str(order[1]) + 'kr'
                                    if params[-1] == 'r':
                                        forward += '_0'
                                        reverse += '_0'
                                    self.parameter(forward, params.pop(0))
                                    self.parameter(reverse, params.pop(0))
                                    self.rule(rule_name, rule_exp, self.model.parameters[forward],
                                              self.model.parameters[reverse])
                                else:
                                    forward = rule_name + '_' + str(order[0]) + 'kc'
                                    if params[-1] == 'r':
                                        forward += '_0'
                                    self.parameter(forward, params.pop(0))
                                    self.rule(rule_name, rule_exp, self.model.parameters[forward])
                            else:
                                if reversible:
                                    forward = rule_name + '_' + str(order[0]) + 'kf'
                                    self.parameter(forward, 1)
                                    reverse = rule_name + '_' + str(order[1]) + 'kr'
                                    self.parameter(reverse, 1)
                                    self.rule(rule_name, rule_exp, self.model.parameters[forward],
                                              self.model.parameters[reverse])
                                else:
                                    forward = rule_name + '_' + str(order[0]) + 'kc'
                                    self.parameter(forward, 1)
                                    print rule_exp
                                    self.rule(rule_name, rule_exp, self.model.parameters[forward])
                                    print
                            n += 1

    def _add_initials(self):

        # todo: add this to GUI; should be node-by-node for incremental mechanistic additions?
        # todo: internal/external detection?

        if self.iv_type == 'calibrate':

            for each in self.monomer_info:

                mon_obj = self.model.monomers[each]

                state_list = [self.model.monomers[each].sites]
                for item in list(product(['on', 'off'], repeat=len(self.model.monomers[each].sites))):
                    state_list.append(list(item))

                index = None
                # print
                for j, every in enumerate(state_list):
                    # print every
                    if j > 0:
                        index = j-1

                        init_name = each
                        active_state = {}
                        for k, thing in enumerate(mon_obj.sites):
                            active_state[thing] = every[k]
                        init_name += '_' + str(index) + '_0'
                        self.parameter(init_name, 1)
                        self.initial(MonomerPattern(mon_obj, active_state, None), self.model.parameters[init_name])

        if self.iv_type == 'pick':

            # This method picks the state that is most different from all opposing states

            for each in self.monomer_info:
                current_best = [0, None]
                if self.nodes[each].initial:
                    for item in self.active_states[each]:
                        item_score = 100
                        for every in self.inactive_states[each]:
                            every_score = 0
                            for i, thing in enumerate(item):
                                if item[thing] != every[thing]:
                                    every_score += 1
                            if every_score < item_score:
                                item_score = deepcopy(every_score)
                        if item_score > current_best[0]:
                            current_best = [deepcopy(item_score), item]
                else:
                    for item in self.inactive_states[each]:
                        item_score = 100
                        for every in self.active_states[each]:
                            every_score = 0
                            for i, thing in enumerate(item):
                                if item[thing] != every[thing]:
                                    every_score += 1
                            if every_score < item_score:
                                item_score = deepcopy(every_score)
                        if item_score > current_best[0]:
                            current_best = [deepcopy(item_score), item]
                mon_obj = self.model.monomers[each]
                init_name = each
                init_state = deepcopy(current_best[1])
                for every in mon_obj.sites:
                    if every not in init_state:  # absence of site_states is assumed
                        init_state[every] = None
                init_name += '_0'
                self.parameter(init_name, 1)
                self.initial(MonomerPattern(mon_obj, init_state, None), self.model.parameters[init_name])

        if self.iv_type == 'distribute':

            # This method distributes '1' over the active or inactive states

            for each in self.monomer_info:

                mon_obj = self.model.monomers[each]

                state_list = [self.model.monomers[each].sites]
                for item in list(product(['on', 'off'], repeat=len(self.model.monomers[each].sites))):
                    state_list.append(list(item))

                # assume initial boolean values are given
                # k = None
                value = float(self.nodes[each].initial) / len(self.active_states[each])
                for i, item in enumerate(self.active_states[each]):

                    index = None
                    for j, every in enumerate(state_list):
                        if j > 0:
                            match = True
                            for k, thing in enumerate(every):
                                if item[state_list[0][k]] != thing:
                                    match = False
                            if match:
                                index = j-1

                    init_name = each
                    active_state = deepcopy(item)
                    for every in mon_obj.sites:
                        if every not in active_state:
                            active_state[every] = None
                    init_name += '_' + str(index) + '_0'
                    self.parameter(init_name, value)
                    self.initial(MonomerPattern(mon_obj, active_state, None), self.model.parameters[init_name])
                    # k = i
                print each
                value = (1.0 - float(self.nodes[each].initial)) / len(self.inactive_states[each])
                for i, item in enumerate(self.inactive_states[each]):

                    index = None
                    for j, every in enumerate(state_list):
                        if j > 0:
                            match = True
                            for k, thing in enumerate(every):
                                if item[state_list[0][k]] != thing:
                                    match = False
                            if match:
                                index = j - 1

                    init_name = each
                    inactive_state = deepcopy(item)
                    for every in mon_obj.sites:
                        if every not in inactive_state:
                            inactive_state[every] = None
                    init_name += '_' + str(index) + '_0'
                    self.parameter(init_name, value)
                    self.initial(MonomerPattern(mon_obj, inactive_state, None), self.model.parameters[init_name])

    def _add_observables(self):

        # add all active states combinations to observables
        # for each in self.active_states:
        #     for i, item in enumerate(self.active_states[each]):
        #
        #         obs_name = each + '_' + str(i) + '_obs'
        #
        #         mon_states = {}
        #         for every in item:
        #             for thing in self.action_info[each]:
        #                 for lotsa in thing[2][0][0]:
        #                     if lotsa == every:
        #                         mon_states[every] = item[every]
        #         for every in mon_states:
        #             if mon_states[every].isdigit():
        #                 mon_states[every] = ANY
        #             if mon_states[every] == 'None':
        #                 mon_states[every] = None
        #         mon_pat = MonomerPattern(self.model.monomers[each], mon_states, None)
        #
        #         self.observable(obs_name, mon_pat)

        # adds all possible site combinations to observables
        for each in self.monomer_info:

            state_list = [self.model.monomers[each].sites]
            for item in list(product(['on', 'off'], repeat=len(self.model.monomers[each].sites))):
                state_list.append(list(item))

            for i, every in enumerate(state_list):
                if i > 0:

                    obs_name = each + '_' + str(i-1) + '_obs'
                    mon_states = {}
                    for j, thing in enumerate(every):
                        mon_states[state_list[0][j]] = thing
                    pat = MonomerPattern(self.model.monomers[each], mon_states, None)
                    self.observable(obs_name, pat)

        # adds only monomers to observables
        for each in self.monomer_info:
            obs_name = each + '_obs'
            self.observable(obs_name, self.model.monomers[each])
